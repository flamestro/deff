name: Release on Main

on:
  push:
    branches:
      - main

permissions:
  contents: write

concurrency:
  group: release-main
  cancel-in-progress: false

jobs:
  release:
    name: Bump version and create release
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Refresh tags
        run: git fetch --force --tags origin

      - name: Configure git author
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Determine release version
        id: version
        run: |
          python - <<'PY'
          import os
          import re
          import subprocess
          import tomllib
          from pathlib import Path

          SEMVER_RE = re.compile(r"(\d+)\.(\d+)\.(\d+)")
          SEMVER_TAG_RE = re.compile(r"v(\d+)\.(\d+)\.(\d+)")
          TYPE_PREFIX_RE = re.compile(r"^(?P<type>feat|fix|chore|docs)(?:\([^)]+\))?!?:", re.IGNORECASE)


          def git_lines(*args: str) -> list[str]:
              completed = subprocess.run(
                  ["git", *args],
                  check=True,
                  text=True,
                  capture_output=True,
              )
              output = completed.stdout.strip()
              if not output:
                  return []
              return [line.strip() for line in output.splitlines() if line.strip()]


          def parse_semver(value: str) -> tuple[int, int, int]:
              match = SEMVER_RE.fullmatch(value.strip())
              if not match:
                  raise ValueError(f"Invalid semver: {value}")
              return tuple(map(int, match.groups()))


          latest_tag = ""
          latest_tag_semver = (0, 0, 0)

          tag_versions = []
          for existing_tag in git_lines("tag", "--list", "v*"):
              tag_match = SEMVER_TAG_RE.fullmatch(existing_tag)
              if tag_match:
                  tag_versions.append((tuple(map(int, tag_match.groups())), existing_tag))

          if tag_versions:
              tag_versions.sort()
              latest_tag_semver, latest_tag = tag_versions[-1]

          commit_range = f"{latest_tag}..HEAD" if latest_tag else "HEAD"
          subjects = git_lines("log", "--format=%s", commit_range)

          bump_level = "patch"
          for subject in subjects:
              prefix_match = TYPE_PREFIX_RE.match(subject)
              if not prefix_match:
                  continue

              commit_type = prefix_match.group("type").lower()
              if commit_type == "feat":
                  bump_level = "minor"
                  break

              if commit_type in {"fix", "chore", "docs"}:
                  bump_level = "patch"

          major, minor, patch = latest_tag_semver
          if bump_level == "minor":
              calculated_version = f"{major}.{minor + 1}.0"
          else:
              calculated_version = f"{major}.{minor}.{patch + 1}"

          cargo_toml_path = Path("Cargo.toml")
          cargo_toml_text = cargo_toml_path.read_text(encoding="utf-8")
          current_version = tomllib.loads(cargo_toml_text)["package"]["version"]

          current_semver = parse_semver(current_version)
          calculated_semver = parse_semver(calculated_version)

          if current_semver >= calculated_semver:
              release_version = current_version
          else:
              release_version = calculated_version

          release_semver = parse_semver(release_version)
          update_needed = current_semver < release_semver
          release_tag = f"v{release_version}"

          print(f"Latest semver tag: {latest_tag or '<none>'}")
          print(f"Analyzed {len(subjects)} commit message(s) in '{commit_range}'")
          print(f"Selected bump level: {bump_level}")
          print(f"Calculated version: {calculated_version}")
          print(f"Cargo.toml version: {current_version}")
          print(f"Release version: {release_version}")
          print(f"Will update Cargo files: {update_needed}")

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as output:
              output.write(f"latest_tag={latest_tag}\n")
              output.write(f"commit_range={commit_range}\n")
              output.write(f"bump_level={bump_level}\n")
              output.write(f"release_version={release_version}\n")
              output.write(f"release_tag={release_tag}\n")
              output.write(f"update_needed={'true' if update_needed else 'false'}\n")
          PY

      - name: Update project version files
        if: steps.version.outputs.update_needed == 'true'
        env:
          RELEASE_VERSION: ${{ steps.version.outputs.release_version }}
        run: |
          python - <<'PY'
          import os
          import re
          import tomllib
          from pathlib import Path


          def parse_semver(value: str) -> tuple[int, int, int]:
              match = re.fullmatch(r"(\d+)\.(\d+)\.(\d+)", value.strip())
              if not match:
                  raise ValueError(value)
              return tuple(map(int, match.groups()))


          release_version = os.environ["RELEASE_VERSION"]
          release_semver = parse_semver(release_version)

          cargo_toml_path = Path("Cargo.toml")
          cargo_toml_text = cargo_toml_path.read_text(encoding="utf-8")
          package = tomllib.loads(cargo_toml_text)["package"]
          package_name = package["name"]
          current_version = package["version"]

          if parse_semver(current_version) >= release_semver:
              print(f"Cargo.toml already at {current_version}; no bump needed")
              raise SystemExit(0)

          lines = cargo_toml_text.splitlines()
          in_package = False
          updated_toml = False

          for index, line in enumerate(lines):
              stripped = line.strip()
              if stripped.startswith("[") and stripped.endswith("]"):
                  in_package = stripped == "[package]"
                  continue

              if in_package and stripped.startswith("version"):
                  indent = line[: len(line) - len(line.lstrip())]
                  lines[index] = f'{indent}version = "{release_version}"'
                  updated_toml = True
                  break

          if not updated_toml:
              raise SystemExit("Could not update [package] version in Cargo.toml")

          cargo_toml_path.write_text("\n".join(lines) + "\n", encoding="utf-8")

          cargo_lock_path = Path("Cargo.lock")
          if cargo_lock_path.exists():
              lock_lines = cargo_lock_path.read_text(encoding="utf-8").splitlines()
              in_package_block = False
              matches_name = False
              updated_lock = False

              for index, line in enumerate(lock_lines):
                  stripped = line.strip()

                  if stripped == "[[package]]":
                      in_package_block = True
                      matches_name = False
                      continue

                  if in_package_block and stripped.startswith("name = "):
                      matches_name = stripped == f'name = "{package_name}"'
                      continue

                  if in_package_block and matches_name and stripped.startswith("version = "):
                      lock_lines[index] = f'version = "{release_version}"'
                      updated_lock = True
                      break

              if updated_lock:
                  cargo_lock_path.write_text("\n".join(lock_lines) + "\n", encoding="utf-8")
          PY

      - name: Commit and push version bump
        if: steps.version.outputs.update_needed == 'true'
        env:
          RELEASE_VERSION: ${{ steps.version.outputs.release_version }}
          BUMP_LEVEL: ${{ steps.version.outputs.bump_level }}
        run: |
          set -euo pipefail

          paths=(Cargo.toml)
          if [ -f Cargo.lock ]; then
            paths+=(Cargo.lock)
          fi

          if git diff --quiet -- "${paths[@]}"; then
            echo "No version bump changes to commit"
            exit 0
          fi

          git add "${paths[@]}"
          git commit -m "chore: bump version to ${RELEASE_VERSION} (${BUMP_LEVEL}) [skip release]"
          git push origin "HEAD:main"

      - name: Create and push release tag
        env:
          RELEASE_TAG: ${{ steps.version.outputs.release_tag }}
        run: |
          set -euo pipefail

          if git ls-remote --exit-code --tags origin "refs/tags/${RELEASE_TAG}" >/dev/null 2>&1; then
            echo "Tag ${RELEASE_TAG} already exists on origin"
            exit 0
          fi

          git tag -a "${RELEASE_TAG}" -m "Release ${RELEASE_TAG}"
          git push origin "${RELEASE_TAG}"

      - name: Create GitHub release
        env:
          GH_TOKEN: ${{ github.token }}
          RELEASE_TAG: ${{ steps.version.outputs.release_tag }}
        run: |
          set -euo pipefail

          if gh release view "${RELEASE_TAG}" >/dev/null 2>&1; then
            echo "Release ${RELEASE_TAG} already exists"
            exit 0
          fi

          gh release create "${RELEASE_TAG}" --title "${RELEASE_TAG}" --generate-notes
