name: Bump Cargo Version

on:
  release:
    types:
      - published

permissions:
  contents: write

concurrency:
  group: bump-version-${{ github.event.release.tag_name }}
  cancel-in-progress: false

jobs:
  bump-version:
    name: Bump Cargo.toml for next release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout default branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.repository.default_branch }}
          fetch-depth: 0
          fetch-tags: true

      - name: Refresh tags
        run: git fetch --force --tags origin

      - name: Configure git author
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Determine bump level and next version
        id: version
        env:
          RELEASE_TAG: ${{ github.event.release.tag_name }}
        run: |
          python - <<'PY'
          import os
          import re
          import subprocess

          SEMVER_TAG_RE = re.compile(r"v(\d+)\.(\d+)\.(\d+)")


          def git_lines(*args: str) -> list[str]:
              completed = subprocess.run(
                  ["git", *args],
                  check=True,
                  text=True,
                  capture_output=True,
              )
              output = completed.stdout.strip()
              if not output:
                  return []
              return [line.strip() for line in output.splitlines() if line.strip()]


          release_tag = os.environ["RELEASE_TAG"].strip()
          match = SEMVER_TAG_RE.fullmatch(release_tag)
          if not match:
              raise SystemExit(f"Release tag '{release_tag}' is not in vMAJOR.MINOR.PATCH format")

          release_version = tuple(map(int, match.groups()))

          tag_versions = []
          for existing_tag in git_lines("tag", "--list", "v*"):
              tag_match = SEMVER_TAG_RE.fullmatch(existing_tag)
              if tag_match:
                  tag_versions.append((tuple(map(int, tag_match.groups())), existing_tag))

          if not any(existing_tag == release_tag for _, existing_tag in tag_versions):
              tag_versions.append((release_version, release_tag))

          tag_versions.sort()
          previous_tag = ""
          for version, existing_tag in tag_versions:
              if version < release_version:
                  previous_tag = existing_tag
              elif version == release_version and existing_tag == release_tag:
                  break

          if previous_tag:
              commit_range = f"{previous_tag}..{release_tag}"
          else:
              commit_range = release_tag

          subjects = git_lines("log", "--format=%s", commit_range)

          type_prefix = re.compile(r"^(?P<type>[a-z]+)(?:\([^)]+\))?!?:")
          bump_level = "patch"
          for subject in subjects:
              prefix_match = type_prefix.match(subject.lower())
              if not prefix_match:
                  continue
              commit_type = prefix_match.group("type")
              if commit_type == "feat":
                  bump_level = "minor"
                  break
              if commit_type in {"chore", "docs"}:
                  bump_level = "patch"

          major, minor, patch = release_version
          if bump_level == "minor":
              next_version = f"{major}.{minor + 1}.0"
          else:
              next_version = f"{major}.{minor}.{patch + 1}"

          print(f"Analyzed {len(subjects)} commit message(s) in '{commit_range}'")
          print(f"Selected bump level: {bump_level}")
          print(f"Next version: {next_version}")

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as output:
              output.write(f"bump_level={bump_level}\n")
              output.write(f"next_version={next_version}\n")
              output.write(f"commit_range={commit_range}\n")
          PY

      - name: Update project version files
        env:
          NEXT_VERSION: ${{ steps.version.outputs.next_version }}
        run: |
          python - <<'PY'
          import os
          import re
          import tomllib
          from pathlib import Path

          def parse_semver(value: str) -> tuple[int, int, int]:
              match = re.fullmatch(r"(\d+)\.(\d+)\.(\d+)", value.strip())
              if not match:
                  raise ValueError(value)
              return tuple(map(int, match.groups()))

          next_version = os.environ["NEXT_VERSION"]
          next_semver = parse_semver(next_version)

          cargo_toml_path = Path("Cargo.toml")
          cargo_toml_text = cargo_toml_path.read_text(encoding="utf-8")
          package = tomllib.loads(cargo_toml_text)["package"]
          package_name = package["name"]
          current_version = package["version"]

          if parse_semver(current_version) >= next_semver:
              print(f"Cargo.toml already at {current_version}; no bump needed")
              raise SystemExit(0)

          lines = cargo_toml_text.splitlines()
          in_package = False
          updated_toml = False

          for index, line in enumerate(lines):
              stripped = line.strip()
              if stripped.startswith("[") and stripped.endswith("]"):
                  in_package = stripped == "[package]"
                  continue

              if in_package and stripped.startswith("version"):
                  indent = line[: len(line) - len(line.lstrip())]
                  lines[index] = f'{indent}version = "{next_version}"'
                  updated_toml = True
                  break

          if not updated_toml:
              raise SystemExit("Could not update [package] version in Cargo.toml")

          cargo_toml_path.write_text("\n".join(lines) + "\n", encoding="utf-8")

          cargo_lock_path = Path("Cargo.lock")
          if cargo_lock_path.exists():
              lock_lines = cargo_lock_path.read_text(encoding="utf-8").splitlines()
              in_package_block = False
              matches_name = False
              updated_lock = False

              for index, line in enumerate(lock_lines):
                  stripped = line.strip()

                  if stripped == "[[package]]":
                      in_package_block = True
                      matches_name = False
                      continue

                  if in_package_block and stripped.startswith("name = "):
                      matches_name = stripped == f'name = "{package_name}"'
                      continue

                  if in_package_block and matches_name and stripped.startswith("version = "):
                      lock_lines[index] = f'version = "{next_version}"'
                      updated_lock = True
                      break

              if updated_lock:
                  cargo_lock_path.write_text("\n".join(lock_lines) + "\n", encoding="utf-8")
          PY

      - name: Commit and push version bump
        env:
          NEXT_VERSION: ${{ steps.version.outputs.next_version }}
          BUMP_LEVEL: ${{ steps.version.outputs.bump_level }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail

          paths=(Cargo.toml)
          if [ -f Cargo.lock ]; then
            paths+=(Cargo.lock)
          fi

          if git diff --quiet -- "${paths[@]}"; then
            echo "No version bump changes to commit"
            exit 0
          fi

          git add "${paths[@]}"
          git commit -m "chore: bump version to ${NEXT_VERSION} (${BUMP_LEVEL}) after ${RELEASE_TAG}"
          git push origin "HEAD:${DEFAULT_BRANCH}"
